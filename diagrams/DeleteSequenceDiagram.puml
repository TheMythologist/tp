@startuml
!include style.puml
skinparam ArrowFontStyle plain

box Logic LOGIC_COLOR_T1
participant ":LogicManager" as LogicManager LOGIC_COLOR
participant ":GreyBookParser" as GreyBookParser LOGIC_COLOR
participant "cp:CommandParser" as CommandParser LOGIC_COLOR
participant "arg:ArgumentParseResult" as ArgumentParseResult LOGIC_COLOR
participant "d:DeleteCommand" as DeleteCommand LOGIC_COLOR
participant "r:CommandResult" as CommandResult LOGIC_COLOR
end box

box Model MODEL_COLOR_T1
participant "m:Model" as Model MODEL_COLOR
end box

[-> LogicManager : execute("delete 1")
activate LogicManager

LogicManager -> GreyBookParser : parse("delete 1")
activate GreyBookParser
note right: Gets 'delete' CommandParser

GreyBookParser -> CommandParser : parse(" 1")
activate CommandParser

' CommandParser identifies arguments, verifies constraints, and creates the result wrapper
create ArgumentParseResult
CommandParser -> ArgumentParseResult
activate ArgumentParseResult
note right: arg stores DeleteCommand (d) \nand parsed arguments

ArgumentParseResult --> CommandParser : arg
deactivate ArgumentParseResult

CommandParser --> GreyBookParser : arg
deactivate CommandParser

GreyBookParser --> LogicManager : arg
deactivate GreyBookParser

' Execution is delegated to the ArgumentParseResult wrapper
LogicManager -> ArgumentParseResult : execute(m)
activate ArgumentParseResult

' ArgumentParseResult internally calls the command execution
ArgumentParseResult -> DeleteCommand : execute(m, arg)
activate DeleteCommand

DeleteCommand -> Model : deletePerson(1)
activate Model

Model --> DeleteCommand
deactivate Model

create CommandResult
DeleteCommand -> CommandResult
activate CommandResult

CommandResult --> DeleteCommand : r
deactivate CommandResult

DeleteCommand --> ArgumentParseResult : r
deactivate DeleteCommand

ArgumentParseResult --> LogicManager : r
deactivate ArgumentParseResult

[<--LogicManager
deactivate LogicManager
@enduml
